#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Chapter:: *)
(*Network in the Continuum*)


(* ::Subsubsection:: *)
(*Loop 2 tasks changing c*)


(* ::Input:: *)
(*(*Preliminaries*)*)
(*(*User Choices*)*)
(*mod=1; (*# different tasks learned in conjunction*)*)
(*numTasks=1;(*# different tasks learned separately*)*)
(*SaveToTable=False; (*Save conductivity as file = "True"*)*)
(*iterations=6;(*# iterations in dynamics of R*)*)
(*IfPeriodic=False;*)
(**)
(*(*Geometry Definitions*)*)
(*(*Domain*)*)
(*xMin=-0.5;*)
(*xMax=0.5;*)
(*yMin=-2.5;*)
(*yMax=2.5;*)
(*in=(x==xMin);*)
(*out=(x==xMax);*)
(*(*geometry at which Poisson eqn.is solved*)*)
(*\[CapitalOmega]=Rectangle[{xMin,yMin},{xMax,yMax}];*)
(*(*Shitty line for mesh generation*)*)
(*Needs["NDSolve`FEM`"]*)
(*mesh=ToElementMesh[\[CapitalOmega]];*)
(**)
(*(*Periodic or Neumann BCs on y*)*)
(*If[IfPeriodic,\[CapitalGamma]Per=PeriodicBoundaryCondition[p[x,y],y==yMin,TranslationTransform[{0,yMax-yMin}]],\[CapitalGamma]=NeumannValue[0,{y==yMin,y==yMax}]];*)
(**)
(*(*Scalars*)*)
(*\[Alpha]=1;(*learning rate*)*)
(*\[Beta]=0.0;(*damping coefficient of gradients in resistance*)*)
(*\[Gamma]=0.15;(*change in R a.f.o current coefficient*)*)
(*y1=1.5;(*position of peak in y pressure*)*)
(*y2=1.5;(*position of peak in y pressure*)*)
(*yout1=-1.5;(*position of peak in output flow*)*)
(*yout2=-1.5;(*position of peak in output flow*)*)
(*\[Sigma]=0.05;(*width of Gaussians*)*)
(*\[Sigma]2=0.1*)
(*Inval={Exp[-(y-y1)^2/\[Sigma]]+0.5,Exp[-(y-y2)^2/\[Sigma]]+0.5};(*Value of pressure at input*)*)
(*InvalUpdateInit:=1.0;*)
(*Targetval[y_]:={1.0*Exp[-(y-yout1)^2/\[Sigma]]+0.75,1.0*Exp[-(y-yout2)^2/\[Sigma]]+0.75};(*Value of flow at input*)*)
(*(*Targetval[y_]:={0.5*Sin[-(y/yout1)/\[Sigma]]+1.25,0.5*Sin[-(y/yout2)/(\[Sigma]2)]+1.25};(*Value of flow at input*)*)*)
(*OutvalMeasure=0.0;(*Value of pressure at output*)*)
(*OutvalUpdateInit:=0.0;(*Value of pressure at output*)*)
(*Clear[c];*)
(*c[x_,y_]:=1;(*initiate conductivity field*)*)
(**)
(*(*Plot Input values and target*)*)
(*Print[Plot[{Inval[[1]],Targetval[y][[1]]},{y,yMin,yMax},PlotStyle->{Blue,Red},PlotRange->{0,2},PlotLabel->"Input and target iteration 1",AxesLabel->{"y","Input and Target"}]];*)
(*Print[Plot[{Inval[[2]],Targetval[y][[2]]},{y,yMin,yMax},PlotStyle->{Blue,Red},PlotRange->{0,2},PlotLabel->"Input and target iteration 1",AxesLabel->{"y","Input and Target"}]];*)
(**)
(*(*For plots*)*)
(*factor = 400;*)
(**)
(*(*Dynamics*)*)
(*(*Loop-learning*)*)
(*LossLst={};*)
(*(*This loop goes over numTasks tasks, calculating two different c fields *)*)
(*Do[*)
(*(*Initiate conductivity and update values*)*)
(*Clear[c];*)
(*Clear[InvalUpdate];*)
(*c[x_,y_]:=1;*)
(*Clear[OutvalUpdate];*)
(*InvalUpdate[x_,y_]:=InvalUpdateInit;*)
(*OutvalUpdate[x_,y_]:=InvalUpdateInit;(*Value of pressure at output*)*)
(**)
(*(*This loop goes over mod tasks, training a single c field*)*)
(*Do[*)
(*k=Mod[i-1,mod]+j; (*task number to learn in conjunction*)*)
(**)
(*(*Define Poisson equation during measurement*)*)
(*op=Inactive[Div][({{c[x,y],0},{0,c[x,y]}} . Inactive[Grad][p[x,y],{x,y}]),{x,y}];*)
(**)
(*(*Set up BCs in inputs and outputs*)*)
(*DirichletConds={DirichletCondition[p[x,y]==Inval[[k]],x==xMin&&yMin<y<yMax],DirichletCondition[p[x,y]==OutvalMeasure,x==xMax&&yMin<y<yMax]};*)
(**)
(*(*Solve Poisson equation*)*)
(*If[IfPeriodic,pfun=NDSolveValue[{op==0,DirichletConds, \[CapitalGamma]Per},p,{x,y}\[Element]\[CapitalOmega]],pfun=NDSolveValue[{op==\[CapitalGamma],DirichletConds},p,{x,y}\[Element]\[CapitalOmega]]];*)
(**)
(*(*Compute Q and its magnitude*)*)
(*Gradp=Grad[pfun[x,y],{x,y}];*)
(*Qx[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[1]]];*)
(*Qy[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[2]]];*)
(*absQ=(Qx^2+Qy^2)^0.5;*)
(**)
(*(*Plot pressure and flow during measurement*)*)
(*(*Print[Plot3D[Evaluate[pfun[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y","p"}]];*)(*Print[VectorPlot[{Qx[x,y],Qy[x,y]},{x,y}\[Element]\[CapitalOmega],PlotLabel->Style["Q (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"}]];*)Print[Plot[{Evaluate[Qx[xMax-0.1,y]],Targetval[y][[k]]},{y,yMin,yMax},PlotStyle->{Blue,Red},PlotRange->{0,2},PlotLabel->"Qx at output as function of y with TargetVal",AxesLabel->{"y","Qx"}]];*)
(**)
(*(*Calculate Loss*)*)
(*Lossfunc[y_]:=Targetval[y][[k]]-Qx[xMax-0.1,y];*)
(*Lossi=NIntegrate[Abs[Lossfunc[y]],{y,yMin,yMax}]/NIntegrate[Abs[Targetval[y][[k]]],{y,yMin,yMax}];*)
(*AppendTo[LossLst,Lossi];*)
(*Print["Loss iteration ",i,": ",Lossi];*)
(*(*Print["Iteration ",i," Lossfunc: ",Lossfunc[y]];*)*)
(**)
(*(*Input values during update modality*)*)
(*(*Interpolate mesh coordinates properly*)*)
(**)
(*(*InvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},InvalUpdate[x,y]+\[Alpha]*Lossfunc[y]]@@@mesh["Coordinates"]];*)*)
(*(*InvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},Inval[[k]]+Lossi]@@@mesh["Coordinates"]];*)*)
(*InvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},Inval[[k]]]@@@mesh["Coordinates"]];*)
(*(*Output values during update modality*)*)
(*OutvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},OutvalUpdate[x,y]-\[Alpha]*Lossfunc[y]]@@@mesh["Coordinates"]];*)
(**)
(*(*Dirichlet conditions during update modality*)*)
(*DirichletCondsUpdate={DirichletCondition[p[x,y]==InvalUpdate[x,y],x==xMin&&yMin<y<yMax],DirichletCondition[p[x,y]==OutvalUpdate[x,y],x==xMax&&yMin<y<yMax]};*)
(**)
(*(*Solve Poisson during update modality*)*)
(*If[IfPeriodic,pfunUpdate=NDSolveValue[{op==0,DirichletCondsUpdate,\[CapitalGamma]Per},p,{x,y}\[Element]\[CapitalOmega]],pfunUpdate=NDSolveValue[{op==\[CapitalGamma],DirichletCondsUpdate},p,{x,y}\[Element]\[CapitalOmega]]];*)
(**)
(*(*Compute Q and its magnitude*)*)
(*GradpUpdate=Grad[pfunUpdate[x,y],{x,y}];*)
(*QxUpdate=-c[x,y]*GradpUpdate[[1]];*)
(*QyUpdate=-c[x,y]*GradpUpdate[[2]];*)
(*absQUpdate=(QxUpdate^2+QyUpdate^2)^0.5;*)
(**)
(*(*Plot results*)*)
(*Print[Plot3D[Evaluate[pfunUpdate[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p Update (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y","p"}]];*)
(*Print[VectorPlot[{QxUpdate,QyUpdate},{x,y}\[Element]\[CapitalOmega],PlotLabel->Style["Q Update modality (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"}]];*)
(**)
(*(*Compute gradient of conductivity*)*)
(*Gradc=Grad[c[x,y],{x,y}];*)
(*absGradc=(Gradc[[1]]^2+Gradc[[2]]^2)^(0.25);*)
(**)
(*(*Update conductivity field,using interpolation*)*)
(*(*c=ElementMeshInterpolation[{mesh},Function[{x,y},\[Gamma] absQUpdate[x,y]-\[Beta] absGradc[x,y]+1;]@@@mesh["Coordinates"]];*)*)
(*c[x_,y_]:=\[Gamma] absQUpdate-\[Beta] absGradc+1;*)
(*cTable=Table[c[x,y],{x,xMin,xMax,0.01},{y,yMin,yMax,0.01}];*)
(*  cTableSmoothed=GaussianFilter[cTable,12];(*Smooth field*)*)
(*cInterp=ListInterpolation[cTableSmoothed,{{xMin,xMax},{yMin,yMax}},InterpolationOrder->1];*)
(*(*cInterp=ListInterpolation[cTable,{{xMin,xMax},{yMin,yMax}},Method->"Hermite"(*,InterpolationOrder->1*)];*)*)
(*c[x_,y_]:=cInterp[x,y];*)
(*(*Print[DensityPlot[c[x,y],{x,xMin,xMax},{y,yMin,yMax},ColorFunction->"TemperatureMap", PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"},FrameLabel->{"x","y"},PlotLegends->BarLegend[{"TemperatureMap",{0,1}}]]];*)*)
(*Print[DensityPlot[c[x,y],{x,xMin,xMax},{y,yMin,yMax},ColorFunction->"TemperatureMap",PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"},FrameLabel->{"x","y"},PlotLegends->Automatic]];*)
(**)
(**)
(*(*Print["Iteration ",i," - Checking cTable Dimensions: ",Dimensions[cTable]];*)
(*  Print["Sample c values: ",Table[c[x,y],{x,xMin,xMax,0.1},{y,yMin,yMax,0.1}]];*)
(*Check[cInterp=ListInterpolation[cTable,{{xMin,xMax},{yMin,yMax}},Method->"Hermite"],Print["Error in ListInterpolation at iteration ",i];Continue[]];*)
(*Print["Iteration ",i," - Interpolation of c Completed"]; *)*)
(**)
(*(*Print[Plot3D[Evaluate[c[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y","c"}]];*)*)
(**)
(*,{i,1,iterations}];*)
(**)
(*(*Plot LossLst as a function of iteration*)*)
(*Print[ListPlot[LossLst,Joined->True,Mesh->All,PlotLabel->"Loss vs Iteration",AxesLabel->{"Iteration","Loss"},PlotRange->{All,{0,0.5}}]];*)
(**)
(*(*Save c to table and continue to new BC*)*)
(*cTaskTable=Table[c[x,y],{x,xMin,xMax,0.01},{y,yMin,yMax,0.01}];*)
(*       cTaskInterp=ListInterpolation[cTaskTable,{{xMin,xMax},{yMin,yMax}},InterpolationOrder->1];*)
(*       cTask[x_,y_]:=cTaskInterp[x,y];(*This is now a frozen copy*)*)
(*    If[SaveToTable,Export["C:\\Users\\SMR_Admin\\OneDrive - huji.ac.il\\PhD\\Research\\Network continuum\\c"<>ToString[j]<>"Table.dat",cTaskTable,"Table"]]*)
(*,{j,1,numTasks}];*)


(* ::Input:: *)
(*cTask1Table=Import["C:\\Users\\SMR_Admin\\OneDrive - huji.ac.il\\PhD\\Research\\Network continuum\\c1Table.dat","Table"];*)
(*cTask2Table=Import["C:\\Users\\SMR_Admin\\OneDrive - huji.ac.il\\PhD\\Research\\Network continuum\\c2Table.dat","Table"];*)


(* ::Input:: *)
(*cTask1Interp=ListInterpolation[cTask1Table,{{xMin,xMax},{yMin,yMax}},InterpolationOrder->1];*)
(*cTask2Interp=ListInterpolation[cTask2Table,{{xMin,xMax},{yMin,yMax}},InterpolationOrder->1];*)
(*cTask1[x_,y_]:=cTask1Interp[x,y];(*This is now a frozen copy*)*)
(*cTask2[x_,y_]:=cTask2Interp[x,y];(*This is now a frozen copy*)*)
(*cTaskLinear[x_,y_]:=cTask1[x,y]+cTask2[x,y];*)


(* ::Input:: *)
(*cTable*)


(* ::Input:: *)
(*cTask1[x,y]*)


(* ::Input:: *)
(*Print[DensityPlot[cTaskLinear[x,y],{x,xMin,xMax},{y,yMin,yMax},ColorFunction->"TemperatureMap",PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"},FrameLabel->{"x","y"},PlotLegends->Automatic]];*)


(* ::Input:: *)
(*Print[ListPlot[LossLst,Joined->True,Mesh->All,PlotLabel->"Loss vs Iteration",AxesLabel->{"Iteration","Loss"},PlotRange->{All,{0,0.55}}]];*)


(* ::Subsubsection:: *)
(*Loop without changing c*)


(* ::Input:: *)
(*mod = 2;*)
(*Do[k=Mod[i-1,mod]+j;*)
(*(*Define Poisson equation during measurement*)*)
(*op=Inactive[Div][({{cTaskLinear[x,y],0},{0,cTaskLinear[x,y]}} . Inactive[Grad][p[x,y],{x,y}]),{x,y}];*)
(**)
(*(*Set up BCs in inputs and outputs*)*)
(*DirichletConds={DirichletCondition[p[x,y]==Inval[[k]],x==xMin],DirichletCondition[p[x,y]==OutvalMeasure,x==xMax]};*)
(**)
(*(*Solve Poisson equation*)*)
(*pfun=NDSolveValue[{op==\[CapitalGamma],DirichletConds},p,{x,y}\[Element]\[CapitalOmega]];*)
(**)
(*(*Compute Q and its magnitude*)*)
(*Gradp=Grad[pfun[x,y],{x,y}];*)
(*Qx[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[1]]];*)
(*Qy[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[2]]];*)
(*absQ=(Qx^2+Qy^2)^0.5;*)
(**)
(*(*Plot pressure and flow during measurement*)*)
(*(*Print[Plot3D[Evaluate[pfun[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y","p"}]];*)(*Print[VectorPlot[{Qx[x,y],Qy[x,y]},{x,y}\[Element]\[CapitalOmega],PlotLabel->Style["Q (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"}]];*)Print[Plot[{Evaluate[Qx[xMax-0.1,y]],Targetval[y][[k]]},{y,yMin,yMax},PlotStyle->{Blue,Red},PlotRange->{0,2},PlotLabel->"Qx at output as function of y with TargetVal",AxesLabel->{"y","Qx"}]];*)
(**)
(*(*Calculate Loss*)*)
(*Lossfunc[y_]:=Targetval[y][[k]]-Qx[xMax-0.1,y];*)
(*Lossi=NIntegrate[Abs[Lossfunc[y]],{y,yMin,yMax}]/NIntegrate[Abs[Targetval[y][[k]]],{y,yMin,yMax}];*)
(*AppendTo[LossLst,Lossi];*)
(*Print["Loss iteration ",i,": ",Lossi];*)
(*(*Print["Iteration ",i," Lossfunc: ",Lossfunc[y]];*)*)
(**)
(**)
(*(*Input values during update modality*)*)
(*InvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},InvalUpdate[x,y]+\[Alpha]*Lossfunc[y]]@@@mesh["Coordinates"]];*)
(*(*InvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},Inval[[k]]+Lossi]@@@mesh["Coordinates"]];*)*)
(*(*Output values during update modality*)*)
(*OutvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},OutvalUpdate[x,y]-\[Alpha]*Lossfunc[y]]@@@mesh["Coordinates"]];*)
(*(*Print["Iteration ",i," InvalUpdate: ",InvalUpdate[x,y]," OutvalUpdate: ",OutvalUpdate[x,y]];*)*)
(**)
(*(*Dirichlet conditions during update modality*)*)
(*DirichletCondsUpdate={DirichletCondition[p[x,y]==InvalUpdate[x,y],x==xMin],DirichletCondition[p[x,y]==OutvalUpdate[x,y],x==xMax]};*)
(**)
(*(*Solve Poisson during update modality*)*)
(*pfunUpdate=NDSolveValue[{op==\[CapitalGamma],DirichletCondsUpdate},p,{x,y}\[Element]\[CapitalOmega]];*)
(**)
(*(*Compute Q and its magnitude*)*)
(*GradpUpdate=Grad[pfunUpdate[x,y],{x,y}];*)
(*QxUpdate=-cTaskLinear[x,y]*GradpUpdate[[1]];*)
(*QyUpdate=-cTaskLinear[x,y]*GradpUpdate[[2]];*)
(*absQUpdate=(QxUpdate^2+QyUpdate^2)^0.5;*)
(**)
(*(*Plot results*)*)
(*(*Print[Plot3D[Evaluate[pfunUpdate[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p Update (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y","p"}]];*)*)
(**)
(*(*Compute gradient of conductivity*)*)
(*Gradc=Grad[cTaskLinear[x,y],{x,y}];*)
(*absGradc=(Gradc[[1]]^2+Gradc[[2]]^2)^(0.25);*)
(**)
(*(*Don't update conductivity*)*)
(*(*Print[DensityPlot[c[x,y],{x,xMin,xMax},{y,yMin,yMax},ColorFunction->"TemperatureMap", PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"},FrameLabel->{"x","y"},PlotLegends->BarLegend[{"TemperatureMap",{0,1}}]]];*)*)
(*Print[DensityPlot[cTaskLinear[x,y],{x,xMin,xMax},{y,yMin,yMax},ColorFunction->"TemperatureMap",PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"},FrameLabel->{"x","y"},PlotLegends->Automatic]];*)
(**)
(*(*Print[Plot3D[Evaluate[c[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y","c"}]];*)*)
(**)
(*,{i,1,iterations}];*)
(**)
(*(*Plot LossLst as a function of iteration*)*)
(*Print[ListPlot[LossLst,Joined->True,Mesh->All,PlotLabel->"Loss vs Iteration",AxesLabel->{"Iteration","Loss"},PlotRange->{All,{0,0.5}}]];*)


(* ::Subsubsection:: *)
(*Periodic BCs that work only without ElementMeshInterpolation*)


(* ::Input:: *)
(*c[x_,y_]:=1.0;*)
(*\[CapitalOmega]=Rectangle[{xMin,yMin},{xMax,yMax}];*)
(*(*Define Poisson equation during measurement*)*)
(*op=Inactive[Div][({{c[x,y],0},{0,c[x,y]}} . Inactive[Grad][p[x,y],{x,y}]),{x,y}];*)
(*(*Set up BCs in inputs and outputs*)*)
(*xMin=-0.5;*)
(*xMax=0.5;*)
(*yMin=-2.5;*)
(*yMax=2.5;*)
(*OutvalMeasure = 0.0;*)
(*y1=1.5;*)
(*y2=-1.5;*)
(*\[Sigma]=\[Pi]*0.5;*)
(*Inval={Sin[y/\[Sigma]],Exp[-(y-y2)^2/\[Sigma]]+0.5};(*Value of pressure at input*)*)
(*k=1;*)
(*(*DirichletConds={DirichletCondition[p[x,y]==Inval[[k]],x==xMin&&yMin<y<yMax],DirichletCondition[p[x,y]==OutvalMeasure,x==xMax&&yMin<y<yMax]};*)*)
(*DirichletConds={DirichletCondition[p[x,y]==Inval[[k]],x==xMin],DirichletCondition[p[x,y]==OutvalMeasure,x==xMax]};*)
(*\[CapitalGamma]Per=PeriodicBoundaryCondition[p[x,y],y==yMin,TranslationTransform[{0,yMax-yMin}]];*)
(*pfun=NDSolveValue[{op==0, DirichletConds,\[CapitalGamma]Per},p,{x,y}\[Element]\[CapitalOmega]];*)
(*Print[Plot3D[Evaluate[pfun[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{-1,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p",16,Bold],AxesLabel->{"x","y","p"}]];*)



