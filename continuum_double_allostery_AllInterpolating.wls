#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Chapter:: *)
(*Network in the Continuum*)


(* ::Input:: *)
(*(*Preliminaries*)*)
(*(*Geometry Definitions*)*)
(*(*Domain*)*)
(*Needs["NDSolve`FEM`"]*)
(*xMin=-0.5;*)
(*xMax=0.5;*)
(*yMin=-2.5;*)
(*yMax=2.5;*)
(*in=(x==xMin);*)
(*out=(x==xMax);*)
(*(*geometry at which Poisson eqn.is solved*)*)
(*\[CapitalOmega]=Rectangle[{xMin,yMin},{xMax,yMax}];*)
(*mesh=ToElementMesh[\[CapitalOmega]];*)
(**)
(*(*Neumann BCs*)*)
(*\[CapitalGamma]=NeumannValue[0,{y==yMin,y==yMax}];*)
(**)
(*(*Scalars*)*)
(*iterations=28;(*# iterations in dynamics of R*)*)
(*\[Alpha]=1;(*learning rate*)*)
(*\[Beta]=0.0;(*damping coefficient of gradients in resistance*)*)
(*\[Gamma]=0.15;(*change in R a.f.o current coefficient*)*)
(*y1=1.5;(*position of peak in y pressure*)*)
(*y2=1.5;(*position of peak in y pressure*)*)
(*yout1=-1.5;(*position of peak in output flow*)*)
(*yout2=-1.5;(*position of peak in output flow*)*)
(*\[Sigma]=0.05;(*width of Gaussians*)*)
(*Inval={Exp[-(y-y1)^2/\[Sigma]]+0.5,Exp[-(y-y2)^2/\[Sigma]]+0.5};(*Value of pressure at input*)*)
(*Clear[InvalUpdate];*)
(*InvalUpdate[x_,y_]:=1.0;*)
(*Targetval[y_]:={1.0*Exp[-(y-yout1)^2/\[Sigma]]+0.75,1.0*Exp[-(y-yout2)^2/\[Sigma]]+0.75};(*Value of flow at input*)*)
(*OutvalMeasure=0.0;(*Value of pressure at output*)*)
(*Clear[OutvalUpdate];*)
(*OutvalUpdate[x_,y_]:=0.0;(*Value of pressure at output*)*)
(*Clear[c]*)
(*c[x_,y_]:=1;(*initiate conductivity field*)*)
(**)
(*(*Rules*)*)
(*(*Poisson Operator*)*)
(*(*calculateOp[c_,p_]:=Inactive[Div][({{c,0},{0,c}}.Inactive[Grad][p,{x,y}]),{x,y}];*)*)
(*calculateOp[c_,p_]:=Inactive[Div][({{c[[1]],0},{0,c[[2]]}} . Inactive[Grad][p,{x,y}]),{x,y}];*)
(*(*Conductivity Rule*)*)
(*updatec[x_,y_,absQ_,absGradc_]:=\[Gamma] absQ-\[Beta] absGradc+1;*)
(*(*updatec[x_,y_,Q_,Gradc_]:=\[Gamma] Q-\[Beta] Gradc+1;*)*)
(**)
(*(*For plots*)*)
(*factor = 400;*)
(**)
(*(*Dynamics*)*)
(*(*Loop-learning*)*)
(**)
(*LossLst={};*)
(*Do[*)
(*(*Define Poisson equation during measurement*)*)
(*op=Inactive[Div][({{c[x,y],0},{0,c[x,y]}} . Inactive[Grad][p[x,y],{x,y}]),{x,y}];*)
(**)
(*(*Set up BCs in inputs and outputs*)*)
(*DirichletConds={DirichletCondition[p[x,y]==Inval[[Mod[i-1,2]+1]],x==xMin],DirichletCondition[p[x,y]==OutvalMeasure,x==xMax]};*)
(**)
(*(*Print["Iteration ",i," - Checking Poisson Solve Measurement Modality"];*)
(*  Print["DirichletConds: ",DirichletConds];*)
(*Check[pfun=NDSolveValue[{op==\[CapitalGamma],DirichletConds},p,{x,y}\[Element]\[CapitalOmega]],Print["Error in NDSolveValue at iteration ",i];Continue[]];*)
(*Print["Iteration ",i," - Poisson Solve Completed Measurement Modality"];*)*)
(**)
(*(*Solve Poisson equation*)*)
(*pfun=NDSolveValue[{op==\[CapitalGamma],DirichletConds},p,{x,y}\[Element]\[CapitalOmega]];*)
(**)
(*(*Compute Q and its magnitude*)*)
(*Gradp=Grad[pfun[x,y],{x,y}];*)
(*Qx[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[1]]];*)
(*Qy[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[2]]];*)
(*absQ=(Qx^2+Qy^2)^0.5;*)
(**)
(*(*Plot pressure and flow during measurement*)*)
(*(*Print[Plot3D[Evaluate[pfun[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y","p"}]];*)(*Print[VectorPlot[{Qx[x,y],Qy[x,y]},{x,y}\[Element]\[CapitalOmega],PlotLabel->Style["Q (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"}]];*)Print[Plot[{Evaluate[Qx[xMax-0.1,y]],Targetval[y][[Mod[i-1,2]+1]]},{y,yMin,yMax},PlotStyle->{Blue,Red},PlotRange->{0,2},PlotLabel->"Qx at output as function of y with TargetVal",AxesLabel->{"y","Qx"}]];*)
(**)
(*(*Calculate Loss*)*)
(*Lossfunc[y_]:=Targetval[y][[Mod[i-1,2]+1]]-Qx[xMax-0.1,y];*)
(*Lossi=NIntegrate[Abs[Lossfunc[y]],{y,yMin,yMax}]/NIntegrate[Abs[Targetval[y][[Mod[i-1,2]+1]]],{y,yMin,yMax}];*)
(*AppendTo[LossLst,Lossi];*)
(*Print["Loss iteration ",i,": ",Lossi];*)
(*(*Print["Iteration ",i," Lossfunc: ",Lossfunc[y]];*)*)
(**)
(**)
(*(*Input values during update modality*)*)
(*InvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},InvalUpdate[x,y]+\[Alpha]*Lossfunc[y]]@@@mesh["Coordinates"]];*)
(*(*InvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},Inval[[Mod[i-1,2]+1]]+Lossi]@@@mesh["Coordinates"]];*)*)
(*(*Output values during update modality*)*)
(*OutvalUpdate=ElementMeshInterpolation[{mesh},Function[{x,y},OutvalUpdate[x,y]-\[Alpha]*Lossfunc[y]]@@@mesh["Coordinates"]];*)
(*(*Print["Iteration ",i," InvalUpdate: ",InvalUpdate[x,y]," OutvalUpdate: ",OutvalUpdate[x,y]];*)*)
(**)
(*(*Dirichlet conditions during update modality*)*)
(*DirichletCondsUpdate={DirichletCondition[p[x,y]==InvalUpdate[x,y],x==xMin],DirichletCondition[p[x,y]==OutvalUpdate[x,y],x==xMax]};*)
(**)
(*(*Print["Iteration ",i," - Checking Poisson Solve Update Modality"];*)
(*  Print["DirichletCondsUpdate: ",DirichletCondsUpdate];*)
(*Check[pfunUpdate=NDSolveValue[{op==\[CapitalGamma],DirichletCondsUpdate},p,{x,y}\[Element]\[CapitalOmega]],Print["Error in NDSolveValue at iteration ",i];Continue[]];*)
(*  Print["Iteration ",i," - Poisson Solve Completed Update Modality"];*)*)
(**)
(*(*Solve Poisson during update modality*)*)
(*pfunUpdate=NDSolveValue[{op==\[CapitalGamma],DirichletCondsUpdate},p,{x,y}\[Element]\[CapitalOmega]];*)
(**)
(*(*Compute Q and its magnitude*)*)
(*GradpUpdate=Grad[pfunUpdate[x,y],{x,y}];*)
(*QxUpdate=-c[x,y]*GradpUpdate[[1]];*)
(*QyUpdate=-c[x,y]*GradpUpdate[[2]];*)
(*absQUpdate=(QxUpdate^2+QyUpdate^2)^0.5;*)
(**)
(*(*Plot results*)*)
(*(*Print[Plot3D[Evaluate[pfunUpdate[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p Update (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y","p"}]];*)*)
(**)
(*(*Compute gradient of conductivity*)*)
(*Gradc=Grad[c[x,y],{x,y}];*)
(*absGradc=(Gradc[[1]]^2+Gradc[[2]]^2)^(0.25);*)
(**)
(*(*Update conductivity field,using interpolation*)*)
(*(*c=ElementMeshInterpolation[{mesh},Function[{x,y},\[Gamma] absQUpdate[x,y]-\[Beta] absGradc[x,y]+1;]@@@mesh["Coordinates"]];*)*)
(*c[x_,y_]:=\[Gamma] absQUpdate-\[Beta] absGradc+1;*)
(*cTable=Table[c[x,y],{x,xMin,xMax,0.01},{y,yMin,yMax,0.01}];*)
(*  cTableSmoothed=GaussianFilter[cTable,12];(*Smooth field*)*)
(*cInterp=ListInterpolation[cTableSmoothed,{{xMin,xMax},{yMin,yMax}},InterpolationOrder->1];*)
(*(*cInterp=ListInterpolation[cTable,{{xMin,xMax},{yMin,yMax}},Method->"Hermite"(*,InterpolationOrder->1*)];*)*)
(*c[x_,y_]:=cInterp[x,y];*)
(*(*Print[DensityPlot[c[x,y],{x,xMin,xMax},{y,yMin,yMax},ColorFunction->"TemperatureMap", PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"},FrameLabel->{"x","y"},PlotLegends->BarLegend[{"TemperatureMap",{0,1}}]]];*)*)
(*Print[DensityPlot[c[x,y],{x,xMin,xMax},{y,yMin,yMax},ColorFunction->"TemperatureMap",PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y"},FrameLabel->{"x","y"},PlotLegends->Automatic]];*)
(**)
(**)
(*(*Print["Iteration ",i," - Checking cTable Dimensions: ",Dimensions[cTable]];*)
(*  Print["Sample c values: ",Table[c[x,y],{x,xMin,xMax,0.1},{y,yMin,yMax,0.1}]];*)
(*Check[cInterp=ListInterpolation[cTable,{{xMin,xMax},{yMin,yMax}},Method->"Hermite"],Print["Error in ListInterpolation at iteration ",i];Continue[]];*)
(*Print["Iteration ",i," - Interpolation of c Completed"]; *)*)
(**)
(*(*Print[Plot3D[Evaluate[c[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["c (Iteration "<>ToString[i]<>")",16,Bold],AxesLabel->{"x","y","c"}]];*)*)
(**)
(*,{i,1,iterations}]*)
(**)
(*(*Plot LossLst as a function of iteration*)*)
(*Print[ListPlot[LossLst,Joined->True,Mesh->All,PlotLabel->"Loss vs Iteration",AxesLabel->{"Iteration","Loss"},PlotRange->{All,{0,0.5}}]];*)


(* ::Input:: *)
(*Print[ListPlot[LossLst,Joined->True,Mesh->All,PlotLabel->"Loss vs Iteration",AxesLabel->{"Iteration","Loss"},PlotRange->{All,{0,0.4}}]];*)
