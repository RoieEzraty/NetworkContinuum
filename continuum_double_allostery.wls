#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Chapter:: *)
(*Network in the Continuum*)


(* ::Subsection:: *)
(*Preliminaries*)


(* ::Subsubsection:: *)
(*Geometry definition*)


(* ::Input:: *)
(*(*Domain*)*)
(*xMin=-0.5;*)
(*xMax=0.5;*)
(*yMin=-2.5;*)
(*yMax=2.5;*)
(*in=(x==xMin);*)
(*out=(x==xMax);*)
(*(*geometry at which Poisson eqn. is solved*)*)
(*\[CapitalOmega]=Rectangle[{xMin,yMin},{xMax,yMax}];*)


(* ::Subsubsection:: *)
(*Neumann BCs at geometry boundaries*)


(* ::Input:: *)
(*Subscript[\[CapitalGamma], N]=NeumannValue[0 ,{y==yMin,y==yMax}];*)


(* ::Subsubsection:: *)
(*Scalars in the problem*)


(* ::Input:: *)
(*iterations=4;(*# iterations in dynamics of R*)*)
(*\[Alpha]=1;(*learning rate*)*)
(*\[Beta]=0.0;(*damping coefficient of gradients in resistance*)*)
(*\[Gamma]=0.15;(*change in R a.f.o current coefficient*)*)
(*Subscript[y, 1]=-1.5;(*position of peak in y pressure*)*)
(*Subscript[y, 2]=1.5;(*position of peak in y pressure*)*)
(*Subscript[y, out1]=-1.5;(*position of peak in output flow*)*)
(*Subscript[y, out2]=1.5;(*position of peak in output flow*)*)
(*\[Sigma]=0.05; (*width of Gaussians*)*)
(*Inval={Exp[-(y-Subscript[y, 1])^2/\[Sigma]]+0.5,Exp[-(y-Subscript[y, 2])^2/\[Sigma]]+0.5};(*Value of pressure at input*)*)
(*InvalUpdate = 1.0;*)
(*Targetval={1.0*Exp[-(y-Subscript[y, out1])^2/\[Sigma]]+0.75,1.0*Exp[-(y-Subscript[y, out2])^2/\[Sigma]]+0.75};(*Value of flow at input*)*)
(*OutvalMeasure=0.0;(*Value of pressure at output*)*)
(*OutvalUpdate=0.0;(*Value of pressure at output*)*)
(*c[x_,y_]:=1; (*initiate conductivity field*)*)


(* ::Subsubsection:: *)
(*Rules*)


(* ::Input:: *)
(*(*Poisson Operator*)*)
(*(*calculateOp[c_,p_]:=Inactive[Div][({{c,0},{0,c}}.Inactive[Grad][p,{x,y}]),{x,y}];*)*)
(*calculateOp[c_,p_]:=Inactive[Div][({{c[[1]],0},{0,c[[2]]}} . Inactive[Grad][p,{x,y}]),{x,y}];*)
(**)
(*(*Conductivity Rule*)*)
(*updatec[x_,y_,absQ_,absGradc_]:=\[Gamma] absQ-\[Beta] absGradc+1;*)
(*(*updatec[x_,y_,Q_,Gradc_]:=\[Gamma] Q-\[Beta] Gradc+1;*)*)


(* ::Subsection:: *)
(*Dynamics*)


(* ::Subsubsection:: *)
(*Loop dynamics - learning*)


(* ::Input:: *)
(*LossLst={};*)
(*Do[*)
(*(*Define Poisson equation during measurement*)*)
(*op=Inactive[Div][({{c[x,y],0},{0,c[x,y]}} . Inactive[Grad][p[x,y],{x,y}]),{x,y}];*)
(*(*Set up BCs in inputs and outputs*)*)
(*DirichletConds={DirichletCondition[p[x,y]==Inval[[Mod[i-1,2]+1]],x==xMin],DirichletCondition[p[x,y]==OutvalMeasure,x==xMax]};*)
(*(*Solve Poisson equation*)*)
(*pfun=NDSolveValue[{op==Subscript[\[CapitalGamma], N],DirichletConds},p,{x,y}\[Element]\[CapitalOmega]];*)
(**)
(*(*Compute Q and its magnitude*)*)
(*Gradp=Grad[pfun[x,y],{x,y}];*)
(*  Qx[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[1]]];*)
(*  Qy[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[2]]];*)
(**)
(*  absQ=(Qx^2+Qy^2)^0.5;*)
(**)
(*(*Plot pressure and flow during measurement*)*)
(*Print[Plot3D[Evaluate[pfun[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p (Iteration "<> ToString[i] <> ")",16,Bold],AxesLabel->{"x","y","p"}]];*)
(*Print[VectorPlot[{Qx[x,y],Qy[x,y]},{x,y}\[Element]\[CapitalOmega],PlotLabel->Style["Q (Iteration " <> ToString[i] <> ")",16,Bold],AxesLabel->{"x","y"}]];*)
(*Print[Plot[{Evaluate[Qx[xMax-0.1,y]],Targetval[[Mod[i-1,2]+1]]},{y,yMin,yMax},PlotStyle->{Blue,Red},PlotRange->{0,2},PlotLabel->"Qx at output as function of y with TargetVal",AxesLabel->{"y","Loss"}]];*)
(**)
(*  (*Calculate Loss*)*)
(*Lossfunc = Targetval[[Mod[i-1,2]+1]]-Qx[xMax-0.1,y];*)
(*Lossi=NIntegrate[Abs[Lossfunc],{y,yMin,yMax}]/NIntegrate[Abs[Targetval[[Mod[i-1,2]+1]]],{y,yMin,yMax}];*)
(*AppendTo[LossLst,Lossi];*)
(*Print["Loss iteration ",i,": ",Lossi];*)
(*Print["Iteration ",i," Lossfunc: ",Lossfunc];*)
(**)
(*(*Input values during update modality*)*)
(*InvalUpdate =InvalUpdate + \[Alpha]* Lossfunc;*)
(*(* InvalUpdateTable = Table[InvalUpdate,{x,xMin,xMax,0.01},{y,yMin,yMax,0.01}];*)
(*InvalUpdateInterp=ListInterpolation[InvalUpdateTable,{{xMin,xMax},{yMin,yMax}}, Method->"Hermite"(*,InterpolationOrder->1*)];*)
(* InvalUpdate=cInterp[x,y];*)*)
(*(*InvalUpdate = Inval[[1]]*)*)
(*(*Output values during update modality*)*)
(*OutvalUpdate =OutvalUpdate-\[Alpha]* Lossfunc ;*)
(*Print["Iteration ",i," InvalUpdate: ",InvalUpdate," OutvalUpdate: ",OutvalUpdate];*)
(**)
(*(*Dirichlet conditions during update modality*)*)
(*DirichletCondsUpdate={DirichletCondition[p[x,y]==InvalUpdate,x==xMin],DirichletCondition[p[x,y]==OutvalUpdate,x==xMax]};*)
(*(*Solve Poisson during update modality*)*)
(*pfunUpdate=NDSolveValue[{op==Subscript[\[CapitalGamma], N],DirichletCondsUpdate},p,{x,y}\[Element]\[CapitalOmega]];*)
(**)
(* (*Compute Q and its magnitude*)*)
(*GradpUpdate=Grad[pfunUpdate[x,y],{x,y}];*)
(*  QxUpdate=-c[x,y]*GradpUpdate[[1]];*)
(*  QyUpdate=-c[x,y]*GradpUpdate[[2]];*)
(*  absQUpdate=(QxUpdate^2+QyUpdate^2)^0.5;*)
(**)
(*  (*Plot results*)*)
(*Print[Plot3D[Evaluate[pfunUpdate[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p Update (Iteration "<> ToString[i] <> ")",16,Bold],AxesLabel->{"x","y","p"}]];*)
(**)
(* (*Compute gradient of conductivity*)*)
(*Gradc=Grad[c[x,y],{x,y}];*)
(*  absGradc=(Gradc[[1]]^2+Gradc[[2]]^2)^(0.25);*)
(**)
(*(*Update conductivity field, using interpolation*)*)
(*(*c[x_,y_]:=\[Gamma] absQUpdate-\[Beta] absGradc+1;*)*)
(*c[x_,y_]:=updatec[x,y,absQUpdate,absGradc];*)
(*  cTable = Table[c[x,y],{x,xMin,xMax,0.01},{y,yMin,yMax,0.01}];*)
(*cInterp=ListInterpolation[cTable,{{xMin,xMax},{yMin,yMax}}, Method->"Hermite"(*,InterpolationOrder->1*)];*)
(*  c[x_,y_]:=cInterp[x,y];*)
(**)
(*  Print[Plot3D[Evaluate[c[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["c (Iteration "<> ToString[i] <> ")",16,Bold],AxesLabel->{"x","y","c"}]];*)
(**)
(*,{i,1,iterations}]*)


(* ::Input:: *)
(*(*Plot LossLst as a function of iteration*)*)
(*Print[ListPlot[LossLst,Joined->True,Mesh->All,PlotLabel->"Loss vs Iteration",AxesLabel->{"Iteration","Loss"}]];*)


(* ::Subsection:: *)
(*Checks*)


(* ::Input:: *)
(*(*c/.{x->-5.166962357130155,y->-3.05`};*)*)
(*(*dataPoints=Select[Flatten[Table[{x,y},{x,-R,R,0.1},{y,-R,R,0.1}],1],RegionMember[\[CapitalOmega],#]&]*)
(*cValues=Table[{\[Gamma] absQ-\[Beta] absGradc+1/. {x->pt[[1]],y->pt[[2]]},pt},{pt,dataPoints}]*)
(*cInterp=Interpolation[cValues,InterpolationOrder->2]*)
(*c=Function[{x,y},cInterp[x,y]]*)*)
(**)


(* ::Subsubsection:: *)
(*Not In Use*)


(* ::Input:: *)
(*(*Collect discrete data of pressure}*)*)
(*(*datap = Select[Flatten[Table[{x,y,pfun[x,y]},{x,xVals},{y,yVals}],1],dataFilter];*)
(*datac = Select[Flatten[Table[{x,y,c},{x,xVals},{y,yVals}],1],dataFilter];*)*)
(**)
(*(*Fit*)*)
(*(*Fitp=Fit[datap,basis,{x,y}];*)*)
(*(*Fitp=NonlinearModelFit[datap,a1 Exp[-((x-1)^2+(y-1)^2)/b1]+a2 Exp[-((x+1)^2+(y+1)^2)/b2]+c1*x+c2*y+d1,{a1,b1,a2,b2, c1, c2, d1},{x,y}]*)*)
(*(*\[Epsilon]=10^-3;*)
(*Fitp=NonlinearModelFit[datap,a1 (1/((x-1)^2+(y-1)^2+\[Epsilon]))^(1/2)+a2(1/((x+1)^2+(y+1)^2+\[Epsilon]))^(1/2)+c1*x+c2*y+d1,{a1,a2, c1, c2, d1},{x,y}];*)*)
(*(*Fitp=NonlinearModelFit[datap,a1 Exp[-(Abs[x-1]+Abs[y-1])/b1]+a2 Exp[-(Abs[x+1]+Abs[y+1])/b2]+c1,{a1,b1,a2,b2, c1},{x,y}]*)*)
(*(*Fitc=Fit[datac,basis,{x,y}]*)*)
(*(*Fitc=NonlinearModelFit[datac,a1 Exp[-((x-1)^2+(y-1)^2)/b1]+a2 Exp[-((x+1)^2+(y+1)^2)/b2]+c1*x+c2*y+d1,{a1,b1,a2,b2, c1, c2, d1},{x,y}]*)*)
(*(*Fitc=NonlinearModelFit[datac,a1 (1/((x-1)^2+(y-1)^2+\[Epsilon]))^(1/2)+a2(1/((x+1)^2+(y+1)^2+\[Epsilon]))^(1/2)+c1*x+c2*y+d1,{a1,a2, c1, c2, d1},{x,y}];*)*)
(*(*Fitc=NonlinearModelFit[datac,a1 Exp[-(Abs[x-1]+Abs[y-1])/b1]+a2 Exp[-(Abs[x+1]+Abs[y+1])/b2]+c1,{a1,b1,a2,b2, c1},{x,y}]*)*)
(*(*cOld=Normal[Fitc]*)*)
(**)
(*(*Plot fit*)*)
(*(*Plot3D[Evaluate[Normal[Fitp]],{x,-2,2},{y,-2,2},RegionFunction->Function[{x,y,z},RegionMember[\[CapitalOmega],{x,y}]],PlotRange->All,Mesh->None,ColorFunction->"TemperatureMap", PlotLabel->Style["p fit",16,Bold],AxesLabel->{"x","y","p polynomial fit"}]*)*)
(**)
(*(*Step A:Store the symbolic expression in a variable,say absQExpr*)*)
(*(*absQExpr=Normal[Fitc]*Expand[(dpdx^2+dpdy^2)^0.5];*)*)
(*(*absQExpr=Expand[((Normal[Fitc]*dpdx)^2+(Normal[Fitc]*dpdy)^2)^0.5];*)*)
(*(*absQExpr=((c*dpdx)^2+(c*dpdy)^2)^0.5*)*)
(*(*absQExpr=((c*Gradp[[1]])^2+(c*Gradp[[2]])^2)^0.5*)*)
(*(*absQExpr=((Fitc*dpdx)^2+(Fitc*dpdy)^2)^0.5*)*)
(**)
(*(*Interpolation for Q*)*)
(*(*absQExprInterp=Interpolation[Table[{x,y,absQExpr},{x,xVals},{y,yVals}],Method->"Linear"];*)
(*absQExpr[x_,y_]:=absQExprInterp[x,y]*)*)
(**)
(*(*Gradient of conductivity*)*)
(*(*absGradc=Expand[(dcdx^2+dcdy^2)^0.5];*)*)
(*(*absGradc=(dcdx^2+dcdy^2)^0.5;*)*)
(**)
(*(*Interpolation for gradient of conductivity*)*)
(*(*absGradcInterp=Interpolation[Table[{x,y,absGradc[x,y]},{x,xVals},{y,yVals}],Method->"Linear"];*)
(*absGradc[x_,y_]:=absGradcInterp[x,y]*)*)
(**)
(*(*Interpolate c again*)*)
(*(*c=Interpolation[Table[{x,y,\[Gamma] absQExpr+1},{x,xVals},{y,yVals}],Method->"Linear"];*)
(*Plot3D[Evaluate[c],{x,xMin,xMax},{y,xMin,xMax},RegionFunction->Function[{x,y,z},RegionMember[\[CapitalOmega],{x,y}]],PlotRange->All,Mesh->None,ColorFunction->"TemperatureMap", PlotLabel->Style["c",16,Bold],AxesLabel->{"x","y","c after interp"}]*)*)
(*(*datac=Select[Flatten[Table[{x,y,c},{x,xVals},{y,yVals}],1],dataFilter];*)
(*Fitc=NonlinearModelFit[datac,a1 Exp[-((x-1)^2+(y-1)^2)/b1]+a2 Exp[-((x+1)^2+(y+1)^2)/b1]+c1*x+c2*y+d1*x^2+d2*y^2+e1,{a1,b1,a2, c1, c2, d1, d2, e1},{x,y}]*)*)
(*(*Fitc=Fit[datac,basis,{x,y}]*)*)
(*(*c=Normal[Fitc];*)*)
(*(*c=Fitc;*)*)
(**)
(*(*Solve p w/interpolation of conductivity*)*)
(*(*op=Div[({{Normal[Fitc],0},{0,Normal[Fitc]}}.Grad[p[x,y],{x,y}]),{x,y}];*)*)
(**)
