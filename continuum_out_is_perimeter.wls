#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Chapter:: *)
(*Network in the Continuum*)


(* ::Subsection:: *)
(*Preliminaries*)


(* ::Subsubsection:: *)
(*Geometry definition*)


(* ::Input:: *)
(*(*Domain*)*)
(*(*(*Outer circle radius*)*)
(*R=6;*)
(*(*Radius around input*)*)
(*r=0.1;*)
(*(*input domain-exclude from geometry*)*)
(*in=(x^2+y^2<=r^2);*)
(*out=(x^2+y^2>=R^2);*)
(*(*geometry at which Poisson eqn.is solved*)*)
(*(*\[CapitalOmega]=RegionDifference[Disk[{0,0},R],Disk[{0,0},r]];*)*)
(*\[CapitalOmega]=ImplicitRegion[!in &&!out,{{x,-R,R},{y,-R,R}}];*)*)
(**)
(*(*Domain*)*)
(*xMin=-1;*)
(*xMax=1;*)
(*yMin=-1;*)
(*yMax=1;*)
(*in=(x==xMin);*)
(*out=(x==xMax);*)
(*(*geometry at which Poisson eqn. is solved*)*)
(*\[CapitalOmega]=Rectangle[{xMin,yMin},{xMax,yMax}];*)


(* ::Subsubsection:: *)
(*Neumann BCs at geometry boundaries*)


(* ::Input:: *)
(*Subscript[\[CapitalGamma], N]=NeumannValue[0 ,{y==yMin,y==yMax}];*)


(* ::Subsubsection:: *)
(*Dirichlet BCs at input and output*)


(* ::Input:: *)
(*(*DirichletConds={DirichletCondition[p[x,y]==Inval,in], DirichletCondition[p[x,y]==Outval,out]};*)*)
(*DirichletConds={DirichletCondition[p[x,y]==Inval,x==xMin],DirichletCondition[p[x,y]==OutvalMeasure,x==xMax]};*)


(* ::Subsubsection:: *)
(*For polynomial fits*)


(* ::Input:: *)
(*n=200;*)
(*xVals=Subdivide[xMin,xMax,n];*)
(*yVals=Subdivide[yMin,yMax,n];*)
(*(*Exclude points inside the small circles from interpolation data*)*)
(*dataFilter[{x_,y_}]:=!(x^2+y^2<=r^2);*)


(* ::Subsubsection:: *)
(*Scalars in the problem*)


(* ::Input:: *)
(*iterations=5;(*# iterations in dynamics of R*)*)
(*\[Alpha]=1;(*learning rate*)*)
(*\[Beta]=0.0;(*damping coefficient of gradients in resistance*)*)
(*\[Gamma]=0.5;(*change in R a.f.o current coefficient*)*)
(*\[Mu]=0.4; (*rapidity of update*)*)
(*Subscript[y, 0]=0.0;(*position of peak in y pressure*)*)
(*Subscript[y, out]=0.5;(*position of peak in output flow*)*)
(*Inval=Exp[-(y-Subscript[y, 0])^2/0.1]+0.5;(*Value of pressure at input*)*)
(*InvalUpdate = 1.0;*)
(*Targetval=1.0*Exp[-(y-Subscript[y, out])^2/0.1]+0.5;(*Value of flow at input*)*)
(*(*Inval = 1.0;*)*)
(*OutvalMeasure=0.0;(*Value of pressure at output*)*)
(*OutvalUpdate=0.0;(*Value of pressure at output*)*)
(*dt=0.2;(*Time step for evolution of conductivity c*)*)
(*basis=Flatten@Table[x^i y^j,{i,0,10},{j,0,10-i}];*)
(*(*Basis for a polynomial fit*)*)
(*(*initiate conductivity field*)*)
(*c[x_,y_]:=1;*)
(*(*c=Sin[x/5]*Sin[y/5]+1*)*)


(* ::Subsection:: *)
(*Dynamics*)


(* ::Subsubsection:: *)
(*Loop dynamics no learning*)


(* ::Input:: *)
(*LossLst={};*)
(*Do[*)
(*(*Define Poisson equation during measurement*)*)
(*op=Inactive[Div][({{c[x,y],0},{0,c[x,y]}} . Inactive[Grad][p[x,y],{x,y}]),{x,y}];*)
(*(*Solve Poisson equation*)*)
(*(*pfun=NDSolveValue[{op==0,DirichletConds},p,{x,y}\[Element]\[CapitalOmega]];*)*)
(*pfun=NDSolveValue[{op==Subscript[\[CapitalGamma], N],DirichletConds},p,{x,y}\[Element]\[CapitalOmega]];*)
(**)
(*(*Compute Q and its magnitude*)*)
(*(*Gradp=Grad[pfun[x,y],{x,y}];*)*)
(*Gradp=Grad[pfun[x,y],{x,y}];*)
(*Qx[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[1]]];*)
(*Qy[x_,y_]:=Evaluate[-c[x,y]*Grad[pfun[x,y],{x,y}][[2]]];*)
(**)
(*absQ=(Qx^2+Qy^2)^0.5;*)
(**)
(*(*Plot pressure and flow during measurement*)*)
(*Print[Plot3D[Evaluate[pfun[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p (Iteration "<> ToString[i] <> ")",16,Bold],AxesLabel->{"x","y","p"}]];*)
(*Print[VectorPlot[{Qx[x,y],Qy[x,y]},{x,y}\[Element]\[CapitalOmega],PlotLabel->Style["Q (Iteration " <> ToString[i] <> ")",16,Bold],AxesLabel->{"x","y"}]];*)
(*Print[Plot[{Evaluate[Qx[xMax-0.1,y]],Targetval},{y,yMin,yMax},PlotStyle->{Blue,Red},PlotRange->{0,2},PlotLabel->"Qx at output as function of y with TargetVal",AxesLabel->{"y","Loss"}]];*)
(**)
(*(*Calculate Loss*)*)
(*(*Lossfunc = Targetval-pfun[0,y];*)*)
(*Lossfunc = Targetval-Qx[xMax-0.1,y];*)
(*Lossi=NIntegrate[Abs[Lossfunc],{y,yMin,yMax}]/NIntegrate[Abs[Targetval],{y,yMin,yMax}];*)
(*AppendTo[LossLst,Lossi];*)
(*Print["Loss iteration ",i,": ",Lossi];*)
(**)
(*(*Plot TargetMinusp as a function of y*)*)
(*(*Print[Plot[Evaluate[Lossfunc],{y,yMin,yMax},PlotLabel->"Loss as function of y",AxesLabel->{"y","Loss"}]];*)*)
(**)
(*(*Input values during update modality*)*)
(*InvalUpdate =InvalUpdate + \[Alpha]* Lossfunc;*)
(*(*Output values during update modality*)*)
(*OutvalUpdate =OutvalUpdate-\[Alpha]* Lossfunc ;*)
(**)
(**)
(*(*Dirichlet conditions during update modality*)*)
(*DirichletCondsUpdate={DirichletCondition[p[x,y]==InvalUpdate,x==xMin],DirichletCondition[p[x,y]==OutvalUpdate,x==xMax]};*)
(*(*Solve Poisson during update modality*)*)
(*pfunUpdate=NDSolveValue[{op==Subscript[\[CapitalGamma], N],DirichletCondsUpdate},p,{x,y}\[Element]\[CapitalOmega]];*)
(**)
(*(*Compute Q and its magnitude*)*)
(*(*Gradp=Grad[pfun[x,y],{x,y}];*)*)
(*GradpUpdate=Grad[pfunUpdate[x,y],{x,y}];*)
(*QxUpdate=-c[x,y]*GradpUpdate[[1]];*)
(*QyUpdate=-c[x,y]*GradpUpdate[[2]];*)
(*absQUpdate=(QxUpdate^2+QyUpdate^2)^0.5;*)
(**)
(*(*Plot results*)*)
(*Print[Plot3D[Evaluate[pfunUpdate[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["p Update (Iteration "<> ToString[i] <> ")",16,Bold],AxesLabel->{"x","y","p"}]];*)
(*(*Print[VectorPlot[{QxUpdate,QyUpdate},{x,y}\[Element]\[CapitalOmega],PlotLabel->Style["Q Update (Iteration " <> ToString[i] <> ")",16,Bold],AxesLabel->{"x","y"}]];*)*)
(*(*Print[Plot3D[Evaluate[absQ],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["||Q||",16,Bold],AxesLabel->{"x","y","||Q||"}]];*)*)
(**)
(*(*Compute gradient of conductivity*)*)
(*Gradc=Grad[c[x,y],{x,y}];*)
(*absGradc=(Gradc[[1]]^2+Gradc[[2]]^2)^(0.25);*)
(**)
(*(*Update conductivity field*)*)
(*(*c=\[Gamma] absQ-\[Beta] absGradc+1;*)*)
(*c[x_,y_]:=\[Gamma] absQUpdate-\[Beta] absGradc+1;*)
(*(*c=\[Gamma] absQUpdate-\[Beta] Laplacian[c,{x,y}]+1;*)*)
(*(*c=(1-\[Mu]) c+\[Mu] (\[Gamma] absQUpdate-\[Beta] absGradc);*)*)
(*cTable = Table[c[x,y],{x,xMin,xMax,0.02},{y,yMin,yMax,0.02}];*)
(*(*Print[cTable];*)*)
(*cInterp=ListInterpolation[cTable,{{xMin,xMax},{yMin,yMax}}, Method->"Hermite"(*,InterpolationOrder->1*)];*)
(**)
(*c[x_,y_]:=cInterp[x,y];*)
(*(*Print[c];*)*)
(**)
(*Print[Plot3D[Evaluate[c[x,y]],{x,y}\[Element]\[CapitalOmega],PlotRange->{All,All,{0,2}},Mesh->None,ColorFunction->"TemperatureMap",PlotLabel->Style["c (Iteration "<> ToString[i] <> ")",16,Bold],AxesLabel->{"x","y","c"}]];*)
(**)
(*,{i,1,iterations}]*)


(* ::Input:: *)
(*(*Plot LossLst as a function of iteration*)*)
(*Print[ListPlot[LossLst,Joined->True,Mesh->All,PlotLabel->"Loss vs Iteration",AxesLabel->{"Iteration","Loss"}]];*)


(* ::Subsection:: *)
(*Checks*)


(* ::Input:: *)
(*(*c/.{x->-5.166962357130155,y->-3.05`};*)*)
(*(*dataPoints=Select[Flatten[Table[{x,y},{x,-R,R,0.1},{y,-R,R,0.1}],1],RegionMember[\[CapitalOmega],#]&]*)
(*cValues=Table[{\[Gamma] absQ-\[Beta] absGradc+1/. {x->pt[[1]],y->pt[[2]]},pt},{pt,dataPoints}]*)
(*cInterp=Interpolation[cValues,InterpolationOrder->2]*)
(*c=Function[{x,y},cInterp[x,y]]*)*)
(**)


(* ::Subsubsection:: *)
(*Not In Use*)


(* ::Input:: *)
(*(*Collect discrete data of pressure}*)*)
(*(*datap = Select[Flatten[Table[{x,y,pfun[x,y]},{x,xVals},{y,yVals}],1],dataFilter];*)
(*datac = Select[Flatten[Table[{x,y,c},{x,xVals},{y,yVals}],1],dataFilter];*)*)
(**)
(*(*Fit*)*)
(*(*Fitp=Fit[datap,basis,{x,y}];*)*)
(*(*Fitp=NonlinearModelFit[datap,a1 Exp[-((x-1)^2+(y-1)^2)/b1]+a2 Exp[-((x+1)^2+(y+1)^2)/b2]+c1*x+c2*y+d1,{a1,b1,a2,b2, c1, c2, d1},{x,y}]*)*)
(*(*\[Epsilon]=10^-3;*)
(*Fitp=NonlinearModelFit[datap,a1 (1/((x-1)^2+(y-1)^2+\[Epsilon]))^(1/2)+a2(1/((x+1)^2+(y+1)^2+\[Epsilon]))^(1/2)+c1*x+c2*y+d1,{a1,a2, c1, c2, d1},{x,y}];*)*)
(*(*Fitp=NonlinearModelFit[datap,a1 Exp[-(Abs[x-1]+Abs[y-1])/b1]+a2 Exp[-(Abs[x+1]+Abs[y+1])/b2]+c1,{a1,b1,a2,b2, c1},{x,y}]*)*)
(*(*Fitc=Fit[datac,basis,{x,y}]*)*)
(*(*Fitc=NonlinearModelFit[datac,a1 Exp[-((x-1)^2+(y-1)^2)/b1]+a2 Exp[-((x+1)^2+(y+1)^2)/b2]+c1*x+c2*y+d1,{a1,b1,a2,b2, c1, c2, d1},{x,y}]*)*)
(*(*Fitc=NonlinearModelFit[datac,a1 (1/((x-1)^2+(y-1)^2+\[Epsilon]))^(1/2)+a2(1/((x+1)^2+(y+1)^2+\[Epsilon]))^(1/2)+c1*x+c2*y+d1,{a1,a2, c1, c2, d1},{x,y}];*)*)
(*(*Fitc=NonlinearModelFit[datac,a1 Exp[-(Abs[x-1]+Abs[y-1])/b1]+a2 Exp[-(Abs[x+1]+Abs[y+1])/b2]+c1,{a1,b1,a2,b2, c1},{x,y}]*)*)
(*(*cOld=Normal[Fitc]*)*)
(**)
(*(*Plot fit*)*)
(*(*Plot3D[Evaluate[Normal[Fitp]],{x,-2,2},{y,-2,2},RegionFunction->Function[{x,y,z},RegionMember[\[CapitalOmega],{x,y}]],PlotRange->All,Mesh->None,ColorFunction->"TemperatureMap", PlotLabel->Style["p fit",16,Bold],AxesLabel->{"x","y","p polynomial fit"}]*)*)
(**)
(*(*Step A:Store the symbolic expression in a variable,say absQExpr*)*)
(*(*absQExpr=Normal[Fitc]*Expand[(dpdx^2+dpdy^2)^0.5];*)*)
(*(*absQExpr=Expand[((Normal[Fitc]*dpdx)^2+(Normal[Fitc]*dpdy)^2)^0.5];*)*)
(*(*absQExpr=((c*dpdx)^2+(c*dpdy)^2)^0.5*)*)
(*(*absQExpr=((c*Gradp[[1]])^2+(c*Gradp[[2]])^2)^0.5*)*)
(*(*absQExpr=((Fitc*dpdx)^2+(Fitc*dpdy)^2)^0.5*)*)
(**)
(*(*Interpolation for Q*)*)
(*(*absQExprInterp=Interpolation[Table[{x,y,absQExpr},{x,xVals},{y,yVals}],Method->"Linear"];*)
(*absQExpr[x_,y_]:=absQExprInterp[x,y]*)*)
(**)
(*(*Gradient of conductivity*)*)
(*(*absGradc=Expand[(dcdx^2+dcdy^2)^0.5];*)*)
(*(*absGradc=(dcdx^2+dcdy^2)^0.5;*)*)
(**)
(*(*Interpolation for gradient of conductivity*)*)
(*(*absGradcInterp=Interpolation[Table[{x,y,absGradc[x,y]},{x,xVals},{y,yVals}],Method->"Linear"];*)
(*absGradc[x_,y_]:=absGradcInterp[x,y]*)*)
(**)
(*(*Interpolate c again*)*)
(*(*c=Interpolation[Table[{x,y,\[Gamma] absQExpr+1},{x,xVals},{y,yVals}],Method->"Linear"];*)
(*Plot3D[Evaluate[c],{x,xMin,xMax},{y,xMin,xMax},RegionFunction->Function[{x,y,z},RegionMember[\[CapitalOmega],{x,y}]],PlotRange->All,Mesh->None,ColorFunction->"TemperatureMap", PlotLabel->Style["c",16,Bold],AxesLabel->{"x","y","c after interp"}]*)*)
(*(*datac=Select[Flatten[Table[{x,y,c},{x,xVals},{y,yVals}],1],dataFilter];*)
(*Fitc=NonlinearModelFit[datac,a1 Exp[-((x-1)^2+(y-1)^2)/b1]+a2 Exp[-((x+1)^2+(y+1)^2)/b1]+c1*x+c2*y+d1*x^2+d2*y^2+e1,{a1,b1,a2, c1, c2, d1, d2, e1},{x,y}]*)*)
(*(*Fitc=Fit[datac,basis,{x,y}]*)*)
(*(*c=Normal[Fitc];*)*)
(*(*c=Fitc;*)*)
(**)
(*(*Solve p w/interpolation of conductivity*)*)
(*(*op=Div[({{Normal[Fitc],0},{0,Normal[Fitc]}}.Grad[p[x,y],{x,y}]),{x,y}];*)*)
(**)
